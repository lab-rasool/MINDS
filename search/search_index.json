{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the MINDS Database Documentation MINDS is a framework designed to integrate multimodal oncology data. It queries and integrates data from multiple sources, including clinical data, genomic data, and imaging data from the NIH NCI CRDC and TCIA portals. [!NOTE] We are currently updating MINDS to include more data sources and improve the user experience. If you have any suggestions or would like to contribute, please feel free to reach out to us. Here is a list of the projects to be included in MINDS (115,974 total patients). Projects in MINDS Project Name Cases Clinical Radiology Histopathology Molecular Foundation Medicine (FM) 18,004 \u2713 \u2713 The Cancer Genome Atlas (TCGA) 11,428 \u2713 \u2713 \u2713 \u2713 Therapeutically Applicable Research to Generate Effective Treatments (TARGET) 6,543 \u2713 \u2713 Clinical Proteomic Tumor Analysis Consortium (CPTAC) 1,656 \u2713 \u2713 \u2713 The Molecular Profiling to Predict Response to Treatment (MP2PRT) 1,562 \u2713 \u2713 Multiple Myeloma Research Foundation (MMRF) 995 \u2713 \u2713 BEATAML1.0 882 \u2713 \u2713 Cancer Genome Characterization Initiatives (CGCI) 645 \u2713 \u2713 \u2713 NCI Center for Cancer Research (NCICCR) 489 \u2713 \u2713 REBC 449 \u2713 \u2713 MATCH 448 \u2713 \u2713 Ukrainian National Research Center for Radiation Medicine Trio Study (TRIO) 339 \u2713 \u2713 Count Me In (CMI) 299 \u2713 \u2713 Human Cancer Model Initiative (HCMI) 278 \u2713 \u2713 \u2713 West Coast Prostrate Cancer Dream Team (WCDT) 101 \u2713 \u2713 Oregon Health and Science University (OHSU) 176 \u2713 \u2713 Applied Proteogenomics OrganizationaL Learning and Outcomes (APOLLO) 87 \u2713 \u2713 EXCEPTIONAL RESPONDERS 84 \u2713 \u2713 Environment And Genetics in Lung Cancer Etiology (EAGLE) 50 \u2713 \u2713 ORGANOID 70 \u2713 \u2713 Clinical Trials Sequencing Project (CTSP) 45 \u2713 \u2713 VA Research Precision Oncology Program (VAREPOP) 7 \u2713 \u2713 4D-Lung 20 \u2713 A091105 83 \u2713 AAPM-RT-MAC 55 \u2713 ACNS0332 85 \u2713 ACRIN-6698 385 \u2713 ACRIN-Contralateral-Breast-MR 984 \u2713 ACRIN-DSC-MR-Brain 123 \u2713 ACRIN-FLT-Breast 83 \u2713 \u2713 ACRIN-FMISO-Brain 45 \u2713 ACRIN-HNSCC-FDG-PET-CT 260 \u2713 ACRIN-NSCLC-FDG-PET 242 \u2713 Adrenal-ACC-Ki67-Seg 53 \u2713 \u2713 Advanced-MRI-Breast-Lesions 632 \u2713 \u2713 \u2713 AHEP0731 80 \u2713 AHOD0831 165 \u2713 AML-Cytomorphology_LMU 200 \u2713 AML-Cytomorphology_MLL_Helmholtz 189 \u2713 Anti-PD-1_Lung 46 \u2713 Anti-PD-1_MELANOMA 47 \u2713 APOLLO-5 414 \u2713 ARAR0331 108 \u2713 AREN0532 544 \u2713 AREN0533 294 \u2713 AREN0534 239 \u2713 B-mode-and-CEUS-Liver 120 \u2713 Bone-Marrow-Cytomorphology_MLL_Helmholtz_Fraunhofer 945 \u2713 Brain-TR-GammaKnife 47 \u2713 Brain-Tumor-Progression 20 \u2713 Breast-Cancer-Screening-DBT 5,060 \u2713 BREAST-DIAGNOSIS 88 \u2713 Breast-Lesions-USG 256 \u2713 Breast-MRI-NACT-Pilot 64 \u2713 Burdenko-GBM-Progression 180 \u2713 C-NMC 2019 118 \u2713 C4KC-KiTS 210 \u2713 CALGB50303 155 \u2713 CBIS-DDSM 1,566 \u2713 CC-Radiomics-Phantom 17 \u2713 CC-Radiomics-Phantom-2 251 \u2713 CC-Tumor-Heterogeneity 23 \u2713 CDD-CESM 326 \u2713 CMB-AML 8 \u2713 \u2713 CMB-CRC 49 \u2713 \u2713 CMB-GEC 7 \u2713 \u2713 CMB-LCA 61 \u2713 \u2713 CMB-MEL 44 \u2713 \u2713 CMB-MML 64 \u2713 \u2713 CMB-PCA 12 \u2713 \u2713 CMMD 1,775 \u2713 \u2713 \u2713 CODEX imaging of HCC 15 \u2713 Colorectal-Liver-Metastases 197 \u2713 COVID-19-AR 105 \u2713 COVID-19-NY-SBU 1,384 \u2713 CRC_FFPE-CODEX_CellNeighs 35 \u2713 CT COLONOGRAPHY 825 \u2713 \u2713 CT Images in COVID-19 661 \u2713 CT Lymph Nodes 176 \u2713 CT-ORG 140 \u2713 CT-Phantom4Radiomics 1 \u2713 CT-vs-PET-Ventilation-Imaging 20 \u2713 CTpred-Sunitinib-panNET 38 \u2713 DFCI-BCH-BWH-PEDs-HGG 61 \u2713 DLBCL-Morphology 209 \u2713 DRO-Toolkit 32 \u2713 Duke-Breast-Cancer-MRI 922 \u2713 EA1141 500 \u2713 ExACT 30 \u2713 FDG-PET-CT-Lesions 900 \u2713 GammaKnife-Hippocampal 390 \u2713 GBM-DSC-MRI-DRO 3 \u2713 GLIS-RT 230 \u2713 HCC-TACE-Seg 105 \u2713 HE-vs-MPM 12 \u2713 Head-Neck Cetuximab 111 \u2713 Head-Neck-PET-CT 298 \u2713 HEAD-NECK-RADIOMICS-HN1 137 \u2713 Healthy-Total-Body-CTs 30 \u2713 HER2 tumor ROIs 273 \u2713 HistologyHSI-GB 13 \u2713 HNC-IMRT-70-33 211 \u2713 HNSCC 627 \u2713 HNSCC-3DCT-RT 31 \u2713 HNSCC-mIF-mIHC-comparison 8 \u2713 Hungarian-Colorectal-Screening 200 \u2713 ISPY1 222 \u2713 ISPY2 719 \u2713 IvyGAP 39 \u2713 LCTSC 60 \u2713 LDCT-and-Projection-data 299 \u2713 LGG-1p19qDeletion 159 \u2713 LIDC-IDRI 1,010 \u2713 Lung Phantom 1 \u2713 Lung-Fused-CT-Pathology 6 \u2713 Lung-PET-CT-Dx 355 \u2713 LungCT-Diagnosis 61 \u2713 Meningioma-SEG-CLASS 96 \u2713 MIDRC-RICORD-1A 110 \u2713 MIDRC-RICORD-1B 117 \u2713 MIDRC-RICORD-1C 361 \u2713 MiMM_SBILab 5 \u2713 NADT-Prostate 37 \u2713 NaF PROSTATE 9 \u2713 NLST 26,254 \u2713 \u2713 NRG-1308 12 \u2713 NSCLC Radiogenomics 211 \u2713 NSCLC-Cetuximab 490 \u2713 NSCLC-Radiomics 422 \u2713 NSCLC-Radiomics-Genomics 89 \u2713 NSCLC-Radiomics-Interobserver1 22 \u2713 OPC-Radiomics 606 \u2713 Osteosarcoma-Tumor-Assessment 4 \u2713 Ovarian Bevacizumab Response 78 \u2713 Pancreas-CT 82 \u2713 Pancreatic-CT-CBCT-SEG 40 \u2713 PCa_Bx_3Dpathology 50 \u2713 \u2713 Pediatric-CT-SEG 359 \u2713 Pelvic-Reference-Data 58 \u2713 Phantom FDA 7 \u2713 Post-NAT-BRCA 64 \u2713 Pretreat-MetsToBrain-Masks 200 \u2713 \u2713 Prostate Fused-MRI-Pathology 28 \u2713 Prostate-3T 64 \u2713 Prostate-Anatomical-Edge-Cases 131 \u2713 PROSTATE-DIAGNOSIS 92 \u2713 PROSTATE-MRI 26 \u2713 Prostate-MRI-US-Biopsy 1,151 \u2713 PROSTATEx 346 \u2713 Pseudo-PHI-DICOM-Data 21 \u2713 PTRC-HGSOC 174 \u2713 QIBA CT-1C 1 \u2713 QIBA-CT-Liver-Phantom 3 \u2713 QIN Breast DCE-MRI 10 \u2713 QIN GBM Treatment Response 54 \u2713 QIN LUNG CT 47 \u2713 QIN PET Phantom 2 \u2713 QIN PROSTATE 22 \u2713 QIN-BRAIN-DSC-MRI 49 \u2713 QIN-BREAST 67 \u2713 QIN-BREAST-02 13 \u2713 QIN-HEADNECK 279 \u2713 QIN-PROSTATE-Repeatability 15 \u2713 QIN-SARCOMA 15 \u2713 RADCURE 3,346 \u2713 \u2713 REMBRANDT 130 \u2713 ReMIND 114 \u2713 RHUH-GBM 40 \u2713 RIDER Breast MRI 5 \u2713 RIDER Lung CT 32 \u2713 RIDER Lung PET-CT 244 \u2713 RIDER NEURO MRI 19 \u2713 RIDER PHANTOM MRI 10 \u2713 RIDER PHANTOM PET-CT 20 \u2713 RIDER Pilot 8 \u2713 S0819 1,299 \u2713 SLN-Breast 78 \u2713 SN-AM 60 \u2713 Soft-tissue-Sarcoma 51 \u2713 SPIE-AAPM Lung CT Challenge 70 \u2713 StageII-Colorectal-CT 230 \u2713 UCSF-PDGM 495 \u2713 UPENN-GBM 630 \u2713 Vestibular-Schwannoma-MC-RC 124 \u2713 Vestibular-Schwannoma-SEG 242 \u2713 VICTRE 2,994 \u2713 Installation Currently the cloud version of MINDS is in closed beta, but, you can still recreate the MINDS database locally. To get the local version of the MINDS database running, you will need to setup a PostgreSQL database and populate it with the MINDS schema. This can be easily done using a docker container. First, you will need to install docker. You can find the installation instructions for your operating system here . Next, you will need to pull the PostgreSQL docker image and run a container with the following command. [!NOTE] Please replace my-secret-pw with your desired password and port with the port you want to use to access the database. The default port for PostgreSQL is 5432. The following command will not work until you replace port with a valid port number. docker run -d --name minds -e POSTGRES_PASSWORD=my-secret-pw -e POSTGRES_DB=minds -p port:5432 postgres Finally, to install the MINDS python package use the following pip command: pip install med-minds After installing the package, please create a .env file in the root directory of the project with the following variables: HOST=127.0.0.1 PORT=5432 DB_USER=postgres PASSWORD=my-secret-pw DATABASE=minds PostgreSQL Migration (v0.0.6) Version 0.0.6 introduces a migration from MySQL to PostgreSQL as the database backend, offering: Better performance for complex queries Advanced data types and indexing options More robust transaction support Better standards compliance If you're upgrading from a previous version that used MySQL, please ensure your database environment is updated to use PostgreSQL 12 or later. Usage Initial setup and automated updates If you have locally setup the MINDS database, then you will need to populate it with data. To do this, or to update the database with the latest data, you can use the following command: # Import the minds package import minds # Update the database with the latest data minds.update() Querying the MINDS database The MINDS python package provides a python interface to the MINDS database. You can use this interface to query the database and return the results as a pandas dataframe. import minds # get a list of all the tables in the database tables = minds.get_tables() # get a list of all the columns in a table columns = minds.get_columns(\"clinical\") # Query the database directly query = \"SELECT * FROM minds.clinical WHERE project_id = 'TCGA-LUAD' LIMIT 10\" df = minds.query(query) Building the cohort and downloading the data # Generate a cohort to download from query query_cohort = minds.build_cohort(query=query, output_dir=\"./data\") # or you can now directly supply a cohort from GDC gdc_cohort = minds.build_cohort(gdc_cohort=\"cohort_Unsaved_Cohort.2024-02-12.tsv\", output_dir=\"./data\") # to get the cohort details gdc_cohort.stats() # to download the data from the cohort to the output directory specified # you can also specify the number of threads to use and the modalities to exclude or include gdc_cohort.download(threads=12, exclude=[\"Slide Image\"]) Please cite our work @Article{s24051634, AUTHOR = {Tripathi, Aakash and Waqas, Asim and Venkatesan, Kavya and Yilmaz, Yasin and Rasool, Ghulam}, TITLE = {Building Flexible, Scalable, and Machine Learning-Ready Multimodal Oncology Datasets}, JOURNAL = {Sensors}, VOLUME = {24}, YEAR = {2024}, NUMBER = {5}, ARTICLE-NUMBER = {1634}, URL = {https://www.mdpi.com/1424-8220/24/5/1634}, ISSN = {1424-8220}, DOI = {10.3390/s24051634} } Contributing We welcome contributions from the community. If you would like to contribute to the MINDS project, please read our contributing guidelines . License This project is licensed under the MIT License - see the LICENSE file for details.","title":"Home"},{"location":"#welcome-to-the-minds-database-documentation","text":"","title":"Welcome to the MINDS Database Documentation"},{"location":"#installation","text":"Currently the cloud version of MINDS is in closed beta, but, you can still recreate the MINDS database locally. To get the local version of the MINDS database running, you will need to setup a PostgreSQL database and populate it with the MINDS schema. This can be easily done using a docker container. First, you will need to install docker. You can find the installation instructions for your operating system here . Next, you will need to pull the PostgreSQL docker image and run a container with the following command. [!NOTE] Please replace my-secret-pw with your desired password and port with the port you want to use to access the database. The default port for PostgreSQL is 5432. The following command will not work until you replace port with a valid port number. docker run -d --name minds -e POSTGRES_PASSWORD=my-secret-pw -e POSTGRES_DB=minds -p port:5432 postgres Finally, to install the MINDS python package use the following pip command: pip install med-minds After installing the package, please create a .env file in the root directory of the project with the following variables: HOST=127.0.0.1 PORT=5432 DB_USER=postgres PASSWORD=my-secret-pw DATABASE=minds","title":"Installation"},{"location":"#postgresql-migration-v006","text":"Version 0.0.6 introduces a migration from MySQL to PostgreSQL as the database backend, offering: Better performance for complex queries Advanced data types and indexing options More robust transaction support Better standards compliance If you're upgrading from a previous version that used MySQL, please ensure your database environment is updated to use PostgreSQL 12 or later.","title":"PostgreSQL Migration (v0.0.6)"},{"location":"#usage","text":"","title":"Usage"},{"location":"#initial-setup-and-automated-updates","text":"If you have locally setup the MINDS database, then you will need to populate it with data. To do this, or to update the database with the latest data, you can use the following command: # Import the minds package import minds # Update the database with the latest data minds.update()","title":"Initial setup and automated updates"},{"location":"#querying-the-minds-database","text":"The MINDS python package provides a python interface to the MINDS database. You can use this interface to query the database and return the results as a pandas dataframe. import minds # get a list of all the tables in the database tables = minds.get_tables() # get a list of all the columns in a table columns = minds.get_columns(\"clinical\") # Query the database directly query = \"SELECT * FROM minds.clinical WHERE project_id = 'TCGA-LUAD' LIMIT 10\" df = minds.query(query)","title":"Querying the MINDS database"},{"location":"#building-the-cohort-and-downloading-the-data","text":"# Generate a cohort to download from query query_cohort = minds.build_cohort(query=query, output_dir=\"./data\") # or you can now directly supply a cohort from GDC gdc_cohort = minds.build_cohort(gdc_cohort=\"cohort_Unsaved_Cohort.2024-02-12.tsv\", output_dir=\"./data\") # to get the cohort details gdc_cohort.stats() # to download the data from the cohort to the output directory specified # you can also specify the number of threads to use and the modalities to exclude or include gdc_cohort.download(threads=12, exclude=[\"Slide Image\"])","title":"Building the cohort and downloading the data"},{"location":"#please-cite-our-work","text":"@Article{s24051634, AUTHOR = {Tripathi, Aakash and Waqas, Asim and Venkatesan, Kavya and Yilmaz, Yasin and Rasool, Ghulam}, TITLE = {Building Flexible, Scalable, and Machine Learning-Ready Multimodal Oncology Datasets}, JOURNAL = {Sensors}, VOLUME = {24}, YEAR = {2024}, NUMBER = {5}, ARTICLE-NUMBER = {1634}, URL = {https://www.mdpi.com/1424-8220/24/5/1634}, ISSN = {1424-8220}, DOI = {10.3390/s24051634} }","title":"Please cite our work"},{"location":"#contributing","text":"We welcome contributions from the community. If you would like to contribute to the MINDS project, please read our contributing guidelines .","title":"Contributing"},{"location":"#license","text":"This project is licensed under the MIT License - see the LICENSE file for details.","title":"License"},{"location":"reference/","text":"Reference Cohort Source code in app/med_minds/__init__.py 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 class Cohort : def __init__ ( self , data , output_dir ): self . data = data self . output_dir = output_dir self . manifest_file = os . path . join ( output_dir , \"manifest.json\" ) if not os . path . exists ( output_dir ): os . makedirs ( output_dir ) def generate_manifest ( self ): aggregator = Aggregator ( self . data , self . output_dir ) aggregator . generate_manifest () def download ( self , threads : int = 4 , include : list = None , exclude : list = None ): if not os . path . exists ( self . manifest_file ): raise FileNotFoundError ( f \"No manifest file found in { self . output_dir } . Please run generate_manifest first.\" ) self . _download_gdc_files ( threads , include = include , exclude = exclude ) self . _download_tcia_files ( threads , include = include , exclude = exclude ) def include ( self , modalities ): print ( f \"Only including { modalities } modalities in download\" ) def stats ( self ): \"\"\"Prints the statistics of the cohort in terms of file count and total size Returns: dict: A dictionary containing the statistics of the cohort \"\"\" with open ( self . manifest_file , \"r\" ) as f : manifest = json . load ( f ) stats_dict = {} for entry in manifest : for key , value in entry . items (): if isinstance ( value , list ): patient_size = 0 for file in value : try : patient_size += file [ \"file_size\" ] except Exception as e : pass if key not in stats_dict : stats_dict [ key ] = { \"file_count\" : len ( value ), \"total_size\" : patient_size , } else : stats_dict [ key ][ \"file_count\" ] += len ( value ) stats_dict [ key ][ \"total_size\" ] += patient_size # Sort the dictionary by total size in descending order sorted_stats = sorted ( stats_dict . items (), key = lambda x : x [ 1 ][ \"total_size\" ], reverse = True ) table = Table ( show_header = True , header_style = \"bold green\" ) table . add_column ( \"Modality\" ) table . add_column ( \"File Count\" ) table . add_column ( \"Total Size\" ) for key , value in sorted_stats : size = value [ \"total_size\" ] if size > 1024 * 1024 * 1024 : size = f \" { size / ( 1024 * 1024 * 1024 ) : .2f } GB\" elif size > 1024 * 1024 : size = f \" { size / ( 1024 * 1024 ) : .2f } MB\" else : size = f \" { size / 1024 : .2f } KB\" table . add_row ( key , str ( value [ \"file_count\" ]), size ) console . print ( table ) return dict ( sorted_stats ) def _download_gdc_files ( self , threads , include = None , exclude = None ): gdc_downloader = GDCFileDownloader ( self . output_dir , MAX_WORKERS = threads , include = include , exclude = exclude ) gdc_downloader . process_cases () def _download_tcia_files ( self , threads , include = None , exclude = None ): tcia_downloader = TCIAFileDownloader ( self . output_dir , MAX_WORKERS = threads , include = include , exclude = exclude ) tcia_downloader . process_cases () stats () Prints the statistics of the cohort in terms of file count and total size Returns: dict \u2013 A dictionary containing the statistics of the cohort Source code in app/med_minds/__init__.py 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 def stats ( self ): \"\"\"Prints the statistics of the cohort in terms of file count and total size Returns: dict: A dictionary containing the statistics of the cohort \"\"\" with open ( self . manifest_file , \"r\" ) as f : manifest = json . load ( f ) stats_dict = {} for entry in manifest : for key , value in entry . items (): if isinstance ( value , list ): patient_size = 0 for file in value : try : patient_size += file [ \"file_size\" ] except Exception as e : pass if key not in stats_dict : stats_dict [ key ] = { \"file_count\" : len ( value ), \"total_size\" : patient_size , } else : stats_dict [ key ][ \"file_count\" ] += len ( value ) stats_dict [ key ][ \"total_size\" ] += patient_size # Sort the dictionary by total size in descending order sorted_stats = sorted ( stats_dict . items (), key = lambda x : x [ 1 ][ \"total_size\" ], reverse = True ) table = Table ( show_header = True , header_style = \"bold green\" ) table . add_column ( \"Modality\" ) table . add_column ( \"File Count\" ) table . add_column ( \"Total Size\" ) for key , value in sorted_stats : size = value [ \"total_size\" ] if size > 1024 * 1024 * 1024 : size = f \" { size / ( 1024 * 1024 * 1024 ) : .2f } GB\" elif size > 1024 * 1024 : size = f \" { size / ( 1024 * 1024 ) : .2f } MB\" else : size = f \" { size / 1024 : .2f } KB\" table . add_row ( key , str ( value [ \"file_count\" ]), size ) console . print ( table ) return dict ( sorted_stats ) build_cohort ( output_dir , query = None , gdc_cohort = None , manifest = None ) Builds a cohort based on a query or a GDC cohort file and returns a Cohort object. Source code in app/med_minds/__init__.py 152 153 154 155 156 157 158 159 160 161 162 163 164 def build_cohort ( output_dir , query = None , gdc_cohort = None , manifest = None ): \"\"\"Builds a cohort based on a query or a GDC cohort file and returns a Cohort object.\"\"\" if query : cohort_data = db . get_minds_cohort ( query ) elif gdc_cohort : cohort_data = db . get_gdc_cohort ( gdc_cohort ) else : raise ValueError ( \"Either a query or a gdc_cohort file must be provided\" ) cohort = Cohort ( cohort_data , output_dir ) if manifest is None : cohort . generate_manifest () return cohort get_columns ( table ) Get the list of columns in a table Parameters table : str The name of the table Returns list A list of columns in the table Source code in app/med_minds/__init__.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 def get_columns ( table ): \"\"\"Get the list of columns in a table Parameters ---------- table : str The name of the table Returns ------- list A list of columns in the table \"\"\" return db . get_columns ( table ) get_tables () Get the list of tables in the database Returns list A list of tables in the database Source code in app/med_minds/__init__.py 19 20 21 22 23 24 25 26 27 def get_tables (): \"\"\"Get the list of tables in the database Returns ------- list A list of tables in the database \"\"\" return db . get_tables () query ( query ) Query the database and return the result as a pandas dataframe Parameters query_string : str The query string to be executed on the database Returns pandas.DataFrame The result of the query Source code in app/med_minds/__init__.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 def query ( query ): \"\"\"Query the database and return the result as a pandas dataframe Parameters ---------- query_string : str The query string to be executed on the database Returns ------- pandas.DataFrame The result of the query \"\"\" return db . execute ( query )","title":"Reference"},{"location":"reference/#reference","text":"","title":"Reference"},{"location":"reference/#app.med_minds.Cohort","text":"Source code in app/med_minds/__init__.py 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 class Cohort : def __init__ ( self , data , output_dir ): self . data = data self . output_dir = output_dir self . manifest_file = os . path . join ( output_dir , \"manifest.json\" ) if not os . path . exists ( output_dir ): os . makedirs ( output_dir ) def generate_manifest ( self ): aggregator = Aggregator ( self . data , self . output_dir ) aggregator . generate_manifest () def download ( self , threads : int = 4 , include : list = None , exclude : list = None ): if not os . path . exists ( self . manifest_file ): raise FileNotFoundError ( f \"No manifest file found in { self . output_dir } . Please run generate_manifest first.\" ) self . _download_gdc_files ( threads , include = include , exclude = exclude ) self . _download_tcia_files ( threads , include = include , exclude = exclude ) def include ( self , modalities ): print ( f \"Only including { modalities } modalities in download\" ) def stats ( self ): \"\"\"Prints the statistics of the cohort in terms of file count and total size Returns: dict: A dictionary containing the statistics of the cohort \"\"\" with open ( self . manifest_file , \"r\" ) as f : manifest = json . load ( f ) stats_dict = {} for entry in manifest : for key , value in entry . items (): if isinstance ( value , list ): patient_size = 0 for file in value : try : patient_size += file [ \"file_size\" ] except Exception as e : pass if key not in stats_dict : stats_dict [ key ] = { \"file_count\" : len ( value ), \"total_size\" : patient_size , } else : stats_dict [ key ][ \"file_count\" ] += len ( value ) stats_dict [ key ][ \"total_size\" ] += patient_size # Sort the dictionary by total size in descending order sorted_stats = sorted ( stats_dict . items (), key = lambda x : x [ 1 ][ \"total_size\" ], reverse = True ) table = Table ( show_header = True , header_style = \"bold green\" ) table . add_column ( \"Modality\" ) table . add_column ( \"File Count\" ) table . add_column ( \"Total Size\" ) for key , value in sorted_stats : size = value [ \"total_size\" ] if size > 1024 * 1024 * 1024 : size = f \" { size / ( 1024 * 1024 * 1024 ) : .2f } GB\" elif size > 1024 * 1024 : size = f \" { size / ( 1024 * 1024 ) : .2f } MB\" else : size = f \" { size / 1024 : .2f } KB\" table . add_row ( key , str ( value [ \"file_count\" ]), size ) console . print ( table ) return dict ( sorted_stats ) def _download_gdc_files ( self , threads , include = None , exclude = None ): gdc_downloader = GDCFileDownloader ( self . output_dir , MAX_WORKERS = threads , include = include , exclude = exclude ) gdc_downloader . process_cases () def _download_tcia_files ( self , threads , include = None , exclude = None ): tcia_downloader = TCIAFileDownloader ( self . output_dir , MAX_WORKERS = threads , include = include , exclude = exclude ) tcia_downloader . process_cases ()","title":"Cohort"},{"location":"reference/#app.med_minds.Cohort.stats","text":"Prints the statistics of the cohort in terms of file count and total size Returns: dict \u2013 A dictionary containing the statistics of the cohort Source code in app/med_minds/__init__.py 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 def stats ( self ): \"\"\"Prints the statistics of the cohort in terms of file count and total size Returns: dict: A dictionary containing the statistics of the cohort \"\"\" with open ( self . manifest_file , \"r\" ) as f : manifest = json . load ( f ) stats_dict = {} for entry in manifest : for key , value in entry . items (): if isinstance ( value , list ): patient_size = 0 for file in value : try : patient_size += file [ \"file_size\" ] except Exception as e : pass if key not in stats_dict : stats_dict [ key ] = { \"file_count\" : len ( value ), \"total_size\" : patient_size , } else : stats_dict [ key ][ \"file_count\" ] += len ( value ) stats_dict [ key ][ \"total_size\" ] += patient_size # Sort the dictionary by total size in descending order sorted_stats = sorted ( stats_dict . items (), key = lambda x : x [ 1 ][ \"total_size\" ], reverse = True ) table = Table ( show_header = True , header_style = \"bold green\" ) table . add_column ( \"Modality\" ) table . add_column ( \"File Count\" ) table . add_column ( \"Total Size\" ) for key , value in sorted_stats : size = value [ \"total_size\" ] if size > 1024 * 1024 * 1024 : size = f \" { size / ( 1024 * 1024 * 1024 ) : .2f } GB\" elif size > 1024 * 1024 : size = f \" { size / ( 1024 * 1024 ) : .2f } MB\" else : size = f \" { size / 1024 : .2f } KB\" table . add_row ( key , str ( value [ \"file_count\" ]), size ) console . print ( table ) return dict ( sorted_stats )","title":"stats"},{"location":"reference/#app.med_minds.build_cohort","text":"Builds a cohort based on a query or a GDC cohort file and returns a Cohort object. Source code in app/med_minds/__init__.py 152 153 154 155 156 157 158 159 160 161 162 163 164 def build_cohort ( output_dir , query = None , gdc_cohort = None , manifest = None ): \"\"\"Builds a cohort based on a query or a GDC cohort file and returns a Cohort object.\"\"\" if query : cohort_data = db . get_minds_cohort ( query ) elif gdc_cohort : cohort_data = db . get_gdc_cohort ( gdc_cohort ) else : raise ValueError ( \"Either a query or a gdc_cohort file must be provided\" ) cohort = Cohort ( cohort_data , output_dir ) if manifest is None : cohort . generate_manifest () return cohort","title":"build_cohort"},{"location":"reference/#app.med_minds.get_columns","text":"Get the list of columns in a table","title":"get_columns"},{"location":"reference/#app.med_minds.get_columns--parameters","text":"table : str The name of the table","title":"Parameters"},{"location":"reference/#app.med_minds.get_columns--returns","text":"list A list of columns in the table Source code in app/med_minds/__init__.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 def get_columns ( table ): \"\"\"Get the list of columns in a table Parameters ---------- table : str The name of the table Returns ------- list A list of columns in the table \"\"\" return db . get_columns ( table )","title":"Returns"},{"location":"reference/#app.med_minds.get_tables","text":"Get the list of tables in the database","title":"get_tables"},{"location":"reference/#app.med_minds.get_tables--returns","text":"list A list of tables in the database Source code in app/med_minds/__init__.py 19 20 21 22 23 24 25 26 27 def get_tables (): \"\"\"Get the list of tables in the database Returns ------- list A list of tables in the database \"\"\" return db . get_tables ()","title":"Returns"},{"location":"reference/#app.med_minds.query","text":"Query the database and return the result as a pandas dataframe","title":"query"},{"location":"reference/#app.med_minds.query--parameters","text":"query_string : str The query string to be executed on the database","title":"Parameters"},{"location":"reference/#app.med_minds.query--returns","text":"pandas.DataFrame The result of the query Source code in app/med_minds/__init__.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 def query ( query ): \"\"\"Query the database and return the result as a pandas dataframe Parameters ---------- query_string : str The query string to be executed on the database Returns ------- pandas.DataFrame The result of the query \"\"\" return db . execute ( query )","title":"Returns"}]}